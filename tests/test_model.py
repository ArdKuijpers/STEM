from typing import Tuple
import pickle

import pytest
from gmsh_utils import gmsh_IO

from stem.model import *
from stem.geometry import *
from tests.utils import TestUtils


class TestModel:

    @pytest.fixture
    def expected_geo_data_0D(self):
        """
        Expected geometry data for a 0D geometry group. The group is a geometry of a point

        Returns:
            - Dict[str, Any]: dictionary containing the geometry data as generated by the gmsh_io
        """
        expected_points = {1: [0, 0, 0], 2: [0.5, 0, 0]}
        return {"points": expected_points}

    @pytest.fixture
    def expected_geometry_single_layer_2D(self):
        """
        Sets expected geometry data for a 2D geometry group. The group is a geometry of a square.

        Returns:
            - :class:`stem.geometry.Geometry`: geometry of a 2D square
        """

        geometry = Geometry()

        geometry.points = [Point.create([0, 0, 0], 1),
                           Point.create([1, 0, 0], 2),
                           Point.create([1, 1, 0], 3),
                           Point.create([0, 1, 0], 4)]

        geometry.lines = [Line.create([1, 2], 1),
                          Line.create([2, 3], 2),
                          Line.create([3, 4], 3),
                          Line.create([4, 1], 4)]

        geometry.surfaces = [Surface.create([1,2,3,4], 1)]

        geometry.volumes = []

        return geometry


    @pytest.fixture
    def expected_geometry_single_layer_3D(self):
        """
        Sets expected geometry data for a 2D geometry group. The group is a geometry of a square.

        Returns:
            - :class:`stem.geometry.Geometry`: geometry of a 2D square
        """

        geometry = Geometry()

        geometry.points = [Point.create([0, 0, 0], 1),
                           Point.create([0, 0, 1], 5),
                           Point.create([1, 0, 1], 6),
                           Point.create([1, 0, 0], 2),
                           Point.create([1, 1, 1], 7),
                           Point.create([1, 1, 0], 3),
                           Point.create([0, 1, 1], 8),
                           Point.create([0, 1, 0], 4)]

        geometry.lines = [Line.create([1, 5], 5),
                          Line.create([5, 6], 7),
                          Line.create([2, 6], 6),
                          Line.create([1, 2], 1),
                          Line.create([6, 7], 9),
                          Line.create([3, 7], 8),
                          Line.create([2, 3], 2),
                          Line.create([7, 8], 11),
                          Line.create([4, 8], 10),
                          Line.create([3, 4], 3),
                          Line.create([8, 5], 12),
                          Line.create([4, 1], 4)]

        geometry.surfaces = [Surface.create([5, 7, -6, -1], 2),
                             Surface.create([6, 9, -8, -2], 3),
                             Surface.create([8,11, -10, -3], 4),
                             Surface.create([10, 12, -5, -4], 5),
                             Surface.create([1, 2, 3, 4], 1),
                             Surface.create([7, 9, 11, 12], 6)]

        geometry.volumes = [Volume.create([-2, -3, -4, -5, -1, 6], 1)]

        return geometry

    @pytest.fixture
    def expected_geometry_single_layer_3D(self):
        """
        Sets expected geometry data for a 2D geometry group. The group is a geometry of a square.

        Returns:
            - :class:`stem.geometry.Geometry`: geometry of a 2D square
        """

        geometry = Geometry()

        geometry.points = [Point.create([0, 0, 0], 1),
                           Point.create([0, 0, 1], 5),
                           Point.create([1, 0, 1], 6),
                           Point.create([1, 0, 0], 2),
                           Point.create([1, 1, 1], 7),
                           Point.create([1, 1, 0], 3),
                           Point.create([0, 1, 1], 8),
                           Point.create([0, 1, 0], 4)]

        geometry.lines = [Line.create([1, 5], 5),
                          Line.create([5, 6], 7),
                          Line.create([2, 6], 6),
                          Line.create([1, 2], 1),
                          Line.create([6, 7], 9),
                          Line.create([3, 7], 8),
                          Line.create([2, 3], 2),
                          Line.create([7, 8], 11),
                          Line.create([4, 8], 10),
                          Line.create([3, 4], 3),
                          Line.create([8, 5], 12),
                          Line.create([4, 1], 4)]

        geometry.surfaces = [Surface.create([5, 7, -6, -1], 2),
                             Surface.create([6, 9, -8, -2], 3),
                             Surface.create([8,11, -10, -3], 4),
                             Surface.create([10, 12, -5, -4], 5),
                             Surface.create([1, 2, 3, 4], 1),
                             Surface.create([7, 9, 11, 12], 6)]

        geometry.volumes = [Volume.create([-2, -3, -4, -5, -1, 6], 1)]

        return geometry

    @pytest.fixture
    def expected_geometry_two_layers_2D(self):
        """
        Sets expected geometries for 2 attached 2D squares.

        Returns:
            - Tuple[:class:`stem.geometry.Geometry`,:class:`stem.geometry.Geometry`]: \
                geometries of 2 attached 2D squares

        """

        geometry_1 = Geometry()

        geometry_1.points = [Point.create([0, 0, 0], 1),
                             Point.create([1, 0, 0], 2),
                             Point.create([1, 1, 0], 3),
                             Point.create([0, 1, 0], 4)]

        geometry_1.lines = [Line.create([1, 2], 1),
                            Line.create([2, 3], 2),
                            Line.create([3, 4], 3),
                            Line.create([4, 1], 4)]

        geometry_1.surfaces = [Surface.create([1, 2, 3, 4], 1)]

        geometry_1.volumes = []

        geometry_2 = Geometry()
        geometry_2.points = [Point.create([1, 1, 0], 3),
                             Point.create([0, 1, 0], 4),
                             Point.create([0, 2, 0], 5),
                             Point.create([1, 2, 0], 6)]

        geometry_2.lines = [Line.create([3, 4], 3),
                            Line.create([4, 5], 5),
                            Line.create([5, 6], 6),
                            Line.create([6, 3], 7)]

        geometry_2.surfaces = [Surface.create([3, 5, 6, 7], 2)]

        geometry_2.volumes = []

        return geometry_1, geometry_2

    @pytest.fixture
    def expected_geometry_two_layers_2D_after_sync(self):
        """
        Sets expected geometry of two model parts and the whole model after synchronising the geometry.

        Returns:
            - Tuple[:class:`stem.geometry.Geometry`,:class:`stem.geometry.Geometry`, \
                :class:`stem.geometry.Geometry`]: geometries of 2 attached 2D squares and the whole model
        """

        # create expected geometry layer 1
        geometry_1 = Geometry()

        geometry_1.points = [Point.create([0, 0, 0], 1),
                             Point.create([1, 0, 0], 2),
                             Point.create([1, 1, 0], 3),
                             Point.create([0.5, 1, 0], 4),
                             Point.create([0, 1, 0], 5)]

        geometry_1.lines = [Line.create([1, 2], 1),
                            Line.create([2, 3], 2),
                            Line.create([3, 4], 3),
                            Line.create([4, 5], 4),
                            Line.create([5, 1], 5)]

        geometry_1.surfaces = [Surface.create([1, 2, 3, 4, 5], 1)]

        geometry_1.volumes = []

        # create expected geometry layer 2
        geometry_2 = Geometry()
        geometry_2.points = [Point.create([1, 1, 0], 3),
                             Point.create([0.5, 1, 0], 4),
                             Point.create([0.5, 2, 0], 6),
                             Point.create([1, 2, 0], 7)]

        geometry_2.lines = [Line.create([3, 4], 3),
                            Line.create([4, 6], 6),
                            Line.create([6, 7], 7),
                            Line.create([7, 3], 8)]

        geometry_2.surfaces = [Surface.create([3, 6, 7, 8], 2)]

        geometry_2.volumes = []

        # create expected full geometry
        full_geometry = Geometry()
        full_geometry.points = [Point.create([0, 0, 0], 1),
                                Point.create([1, 0, 0], 2),
                                Point.create([1, 1, 0], 3),
                                Point.create([0.5, 1, 0], 4),
                                Point.create([0, 1, 0], 5),
                                Point.create([0.5, 2, 0], 6),
                                Point.create([1, 2, 0], 7)]

        full_geometry.lines = [Line.create([1, 2], 1),
                               Line.create([2, 3], 2),
                               Line.create([3, 4], 3),
                               Line.create([4, 5], 4),
                               Line.create([5, 1], 5),
                               Line.create([4, 6], 6),
                               Line.create([6, 7], 7),
                               Line.create([7, 3], 8)]

        full_geometry.surfaces = [Surface.create([1, 2, 3, 4, 5], 1),
                                  Surface.create([3, 6, 7, 8], 2)]

        full_geometry.volumes = []

        return geometry_1, geometry_2, full_geometry

    @pytest.fixture
    def expected_geometry_line_load(self):
        """
        Sets expected geometry data for a 2D geometry group. The group is a geometry of a square.

        Returns:
            - :class:`stem.geometry.Geometry`: geometry of a 2D square
        """

        geometry = Geometry()

        geometry.points = [Point.create([0, 0, 0], 1),
                           Point.create([3, 0, 0], 2),
                           Point.create([4, -1, 0], 3),
                           Point.create([10, -1, 0], 4)]

        geometry.lines = [Line.create([1, 2], 1),
                          Line.create([2, 3], 2),
                          Line.create([3, 4], 3)]

        geometry.surfaces = []

        geometry.volumes = []

        return geometry

    @pytest.fixture
    def create_default_2d_soil_material(self):
        """
        Create a default soil material for a 2D geometry.

        Returns:
            - :class:`stem.soil_material.SoilMaterial`: default soil material

        """
        # define soil material
        ndim = 2
        soil_formulation = OnePhaseSoil(ndim, IS_DRAINED=True, DENSITY_SOLID=2650, POROSITY=0.3)
        constitutive_law = LinearElasticSoil(YOUNG_MODULUS=100e6, POISSON_RATIO=0.3)
        soil_material = SoilMaterial(name="soil", soil_formulation=soil_formulation, constitutive_law=constitutive_law,
                                     retention_parameters=SaturatedBelowPhreaticLevelLaw())
        return soil_material

    @pytest.fixture
    def create_default_3d_soil_material(self):
        """
        Create a default soil material for a 3D geometry.

        Returns:
            - :class:`stem.soil_material.SoilMaterial`: default soil material

        """
        # define soil material
        ndim = 3
        soil_formulation = OnePhaseSoil(ndim, IS_DRAINED=True, DENSITY_SOLID=2650, POROSITY=0.3)
        constitutive_law = LinearElasticSoil(YOUNG_MODULUS=100e6, POISSON_RATIO=0.3)
        soil_material = SoilMaterial(name="soil", soil_formulation=soil_formulation, constitutive_law=constitutive_law,
                                     retention_parameters=SaturatedBelowPhreaticLevelLaw())
        return soil_material

    @pytest.fixture
    def create_default_point_load_parameters(self):
        """
        Create a default point load parameters.

        Returns:
            - :class:`stem.load.PointLoad`: default point load

        """
        # define soil material
        return PointLoad(active=[False, True, False], value=[0, -200, 0])

    @pytest.fixture
    def create_default_line_load_parameters(self):
        """
        Create a default line load parameters.

        Returns:
            - :class:`stem.load.PointLoad`: default point load

        """
        # define soil material
        return LineLoad(active=[False, True, False], value=[0, -20, 0])

    @pytest.fixture
    def create_default_surface_load_parameters(self):
        """
        Create a default surface load properties.

        Returns:
            - :class:`stem.load.SurfaceLoad`: default surface load

        """
        # define soil material
        return SurfaceLoad(active=[False, True, False], value=[0, -2, 0])

    @pytest.fixture
    def create_default_moving_load_parameters(self):
        """
        Create a default surface load properties.

        Returns:
            - :class:`stem.load.SurfaceLoad`: default surface load

        """
        # define soil material
        return MovingLoad(
            origin=[5.0, 0.0, 0.0],
            load=[0.0, -10.0, 0.0],
            velocity=5.0,
            offset=3.0,
            direction=[1, 1, 1]
        )


    @pytest.fixture
    def expected_geometry_two_layers_3D_extruded(self):
        """
        Expected geometry data for a 3D geometry create from 2D extrusion. The geometry is 2 stacked blocks, where the
        top and bottom blocks are in different groups.

        Returns:
            - Tuple[:class:`stem.geometry.Geometry`,:class:`stem.geometry.Geometry`]: expected geometry data
        """

        geometry_1 = Geometry()

        geometry_1.points = [Point.create([0, 0, 0], 1),
                           Point.create([0, 0, 1], 2),
                           Point.create([1, 0, 1], 4),
                           Point.create([1, 0, 0], 3),
                           Point.create([1, 1, 1], 6),
                           Point.create([1, 1, 0], 5),
                           Point.create([0, 1, 1], 8),
                           Point.create([0, 1, 0], 7)]

        geometry_1.lines = [Line.create([1, 2], 1),
                          Line.create([2, 4], 4),
                          Line.create([3, 4], 2),
                          Line.create([1, 3], 3),
                          Line.create([4, 6], 7),
                          Line.create([5, 6], 5),
                          Line.create([3, 5], 6),
                          Line.create([6, 8], 10),
                          Line.create([7, 8], 8),
                          Line.create([5, 7], 9),
                          Line.create([8, 2], 12),
                          Line.create([7, 1], 11)]

        geometry_1.surfaces = [Surface.create([1, 4, -2, -3], 1),
                             Surface.create([2, 7, -5, -6], 2),
                             Surface.create([5, 10, -8, -9], 3),
                             Surface.create([8, 12, -1, -11], 4),
                             Surface.create([3, 6, 9, 11], 5),
                             Surface.create([4, 7, 10, 12], 6)]

        geometry_1.volumes = [Volume.create([-1, -2, -3, -4, -5, 6], 1)]

        geometry_2 = Geometry()

        geometry_2.points = [Point.create([1., 1., 0.], 5),
                             Point.create([1., 1., 1.], 6),
                             Point.create([0.0, 1., 1.], 8),
                             Point.create([0, 1., 0.], 7),
                             Point.create([0., 2., 1], 10),
                             Point.create([0., 2., 0], 9),
                             Point.create([1, 2., 1], 12),
                             Point.create([1, 2., 0], 11)]

        geometry_2.lines = [Line.create([5, 6], 5),
                            Line.create([6, 8], 10),
                            Line.create([7, 8], 8),
                            Line.create([5, 7], 9),
                            Line.create([8, 10], 15),
                            Line.create([9, 10], 13),
                            Line.create([7, 9], 14),
                            Line.create([10, 12], 18),
                            Line.create([11, 12], 16),
                            Line.create([9, 11], 17),
                            Line.create([12, 6], 20),
                            Line.create([11, 5], 19)]

        geometry_2.surfaces = [Surface.create([5, 10, -8, -9], 3),
                               Surface.create([8, 15, -13, -14], 7),
                               Surface.create([13, 18, -16, -17], 8),
                               Surface.create([16, 20, -5, -19], 9),
                               Surface.create([9, 14, 17, 19], 10),
                               Surface.create([10, 15, 18, 20], 11)]

        geometry_2.volumes = [Volume.create([3, 7, 8, 9, 10, -11], 2)]

        return geometry_1, geometry_2

    @pytest.fixture
    def expected_geometry_two_layers_3D_geo_file(self):
        """
        Expected geometry data for a 3D geometry create in a geo file. The geometry is 2 stacked blocks, where the top
        and bottom blocks are in different groups.

        Returns:
            - Tuple[:class:`stem.geometry.Geometry`,:class:`stem.geometry.Geometry`]: expected geometry data
        """

        geometry_1 = Geometry()
        geometry_1.volumes = [Volume.create([-10, 39, 26, 30, 34, 38], 1)]
        geometry_1.surfaces = [Surface.create([5, 6, 7, 8], 10),
                               Surface.create([19, 20, 21, 22], 39),
                               Surface.create([5, 25, -19, -24], 26),
                               Surface.create([6, 29, -20, -25], 30),
                               Surface.create([7, 33, -21, -29], 34),
                               Surface.create([8, 24, -22, -33], 38)]

        geometry_1.lines = [Line.create([1, 2], 5),
                            Line.create([2, 3], 6),
                            Line.create([3, 4], 7),
                            Line.create([4, 1], 8),
                            Line.create([13, 14], 19),
                            Line.create([14, 18], 20),
                            Line.create([18, 22], 21),
                            Line.create([22, 13], 22),
                            Line.create([2, 14], 25),
                            Line.create([1, 13], 24),
                            Line.create([3, 18], 29),
                            Line.create([4, 22], 33)]

        geometry_1.points = [Point.create([0., 0., 0.], 1),
                             Point.create([0.5, 0., 0.], 2),
                             Point.create([0.5, 1., 0.], 3),
                             Point.create([0., 1., 0.], 4),
                             Point.create([0., 0., -0.5], 13),
                             Point.create([0.5, 0., -0.5], 14),
                             Point.create([0.5, 1., -0.5], 18),
                             Point.create([0., 1., -0.5], 22)]

        geometry_2 = Geometry()
        geometry_2.volumes = [Volume.create([-17, 61, -48, -34, -56, -60], 2)]

        geometry_2.surfaces = [Surface.create([-13, -7, -15, -14],17),
                               Surface.create([41, -21, 43, 44], 61),
                               Surface.create([-13, 33, -41, -46], 48),
                               Surface.create([7, 33, -21, -29], 34),
                               Surface.create([-15, 55, -43, -29], 56),
                               Surface.create([-14, 46, -44, -55], 60)]

        geometry_2.lines = [Line.create([4, 11], 13),
                            Line.create([3, 4], 7),
                            Line.create([12, 3], 15),
                            Line.create([11, 12], 14),
                            Line.create([23, 22], 41),
                            Line.create([18, 22], 21),
                            Line.create([18, 32], 43),
                            Line.create([32, 23], 44),
                            Line.create([4, 22], 33),
                            Line.create([11, 23], 46),
                            Line.create([3, 18], 29),
                            Line.create([12, 32], 55)]

        geometry_2.points = [Point.create([0., 1., 0.], 4),
                             Point.create([0., 2., 0.], 11),
                             Point.create([0.5, 1., 0.], 3),
                             Point.create([0.5, 2., 0.], 12),
                             Point.create([0., 2., -0.5], 23),
                             Point.create([0., 1., -0.5], 22),
                             Point.create([0.5, 1., -0.5], 18),
                             Point.create([0.5, 2., -0.5], 32)]

        return geometry_1, geometry_2

    @pytest.fixture(autouse=True)
    def close_gmsh(self):
        """
        Initializer to close gmsh if it was not closed before. In case a test fails, the destroyer method is not called
        on the Model object and gmsh keeps on running. Therefore, nodes, lines, surfaces and volumes ids are not
        reset to one. This causes also the next test after the failed one to fail as well, which has nothing to do
        the test themselves.

        Returns:
            - None

        """
        gmsh_IO.GmshIO().finalize_gmsh()

    def test_add_single_soil_layer_2D(self, expected_geometry_single_layer_2D: Geometry,
                                      create_default_2d_soil_material: SoilMaterial):
        """
        Test if a single soil layer is added correctly to the model in a 2D space. A single soil layer is generated
        and a single soil material is created and added to the model.

        Args:
            - expected_geometry_single_layer_2D (:class:`stem.geometry.Geometry`): expected geometry of the model
            - create_default_2d_soil_material (:class:`stem.soil_material.SoilMaterial`): default soil material

        """

        ndim = 2

        layer_coordinates = [(0, 0, 0), (1, 0, 0), (1, 1, 0), (0, 1, 0)]

        # define soil material
        soil_material = create_default_2d_soil_material

        # create model
        model = Model(ndim)

        # add soil layer
        model.add_soil_layer_by_coordinates(layer_coordinates, soil_material, "soil1")

        # check if layer is added correctly
        assert len(model.body_model_parts) == 1
        assert model.body_model_parts[0].name == "soil1"
        assert model.body_model_parts[0].material == soil_material

        # check if geometry is added correctly
        generated_geometry = model.body_model_parts[0].geometry
        expected_geometry = expected_geometry_single_layer_2D

        # check if points are added correctly
        TestUtils.assert_almost_equal_geometries(expected_geometry, generated_geometry)

    def test_add_single_soil_layer_3D(self, expected_geometry_single_layer_3D: Geometry,
                                      create_default_3d_soil_material: SoilMaterial):
        """
        Test if a single soil layer is added correctly to the model in a 3D space. A single soil layer is generated
        and a single soil material is created and added to the model.

        Args:
            - expected_geometry_single_layer_3D (:class:`stem.geometry.Geometry`): expected geometry of the model
            - create_default_3d_soil_material (:class:`stem.soil_material.SoilMaterial`): default soil material

        """

        ndim = 3

        layer_coordinates = [(0, 0, 0), (1, 0, 0), (1, 1, 0), (0, 1, 0)]

        # define soil material
        soil_material = create_default_3d_soil_material

        # create model
        model = Model(ndim)
        model.extrusion_length = [0, 0, 1]

        # add soil layer
        model.add_soil_layer_by_coordinates(layer_coordinates, soil_material, "soil1")

        # check if layer is added correctly
        assert len(model.body_model_parts) == 1
        assert model.body_model_parts[0].name == "soil1"
        assert model.body_model_parts[0].material == soil_material

        # check if geometry is added correctly
        generated_geometry = model.body_model_parts[0].geometry
        expected_geometry = expected_geometry_single_layer_3D

        # check if points are added correctly
        TestUtils.assert_almost_equal_geometries(expected_geometry, generated_geometry)

    def test_add_multiple_soil_layers_2D(self, expected_geometry_two_layers_2D: Tuple[Geometry, Geometry],
                                         create_default_2d_soil_material: SoilMaterial):
        """
        Test if multiple soil layers are added correctly to the model in a 2D space. Multiple soil layers are generated
        and multiple soil materials are created and added to the model.

        Args:
            - expected_geometry_two_layers_2D (Tuple[:class:`stem.geometry.Geometry`, :class:`stem.geometry.Geometry`]): \
                expected geometry of the model
            - create_default_2d_soil_material (:class:`stem.soil_material.SoilMaterial`): default soil material

        """

        ndim = 2

        layer1_coordinates = [(0, 0, 0), (1, 0, 0), (1, 1, 0), (0, 1, 0)]
        layer2_coordinates = [(1, 1, 0), (0, 1, 0), (0, 2, 0), (1, 2, 0)]

        # define soil materials
        soil_material1 = create_default_2d_soil_material
        soil_material1.name = "soil1"

        soil_material2 = create_default_2d_soil_material
        soil_material2.name = "soil2"

        # create model
        model = Model(ndim)

        # add soil layers
        model.add_soil_layer_by_coordinates(layer1_coordinates, soil_material1, "layer1")
        model.add_soil_layer_by_coordinates(layer2_coordinates, soil_material2, "layer2")

        # check if layers are added correctly
        assert len(model.body_model_parts) == 2
        assert model.body_model_parts[0].name == "layer1"
        assert model.body_model_parts[0].material == soil_material1
        assert model.body_model_parts[1].name == "layer2"
        assert model.body_model_parts[1].material == soil_material2

        # check if geometry is added correctly for each layer
        for i in range(len(model.body_model_parts)):
            generated_geometry = model.body_model_parts[i].geometry
            expected_geometry = expected_geometry_two_layers_2D[i]

            TestUtils.assert_almost_equal_geometries(expected_geometry, generated_geometry)

    def test_add_multiple_soil_layers_3D(self, expected_geometry_two_layers_3D_extruded: Tuple[Geometry, Geometry],
                                         create_default_3d_soil_material: SoilMaterial):
        """
        Test if multiple soil layers are added correctly to the model in a 3D space. Multiple soil layers are generated
        and multiple soil materials are created and added to the model.

        Args:
            - expected_geometry_two_layers_3D_extruded (Tuple[:class:`stem.geometry.Geometry`, \
                :class:`stem.geometry.Geometry`]): expected geometry of the model which is created by extruding \
                a 2D geometry
            - create_default_3d_soil_material (:class:`stem.soil_material.SoilMaterial`): default soil material

        """

        ndim = 3

        layer1_coordinates = [(0, 0, 0), (1, 0, 0), (1, 1, 0), (0, 1, 0)]
        layer2_coordinates = [(1, 1, 0), (0, 1, 0), (0, 2, 0), (1, 2, 0)]

        # define soil materials
        soil_material1 = create_default_3d_soil_material
        soil_material1.name = "soil1"

        soil_material2 = create_default_3d_soil_material
        soil_material2.name = "soil2"

        # create model
        model = Model(ndim)
        model.extrusion_length = [0, 0, 1]

        # add soil layers
        model.add_soil_layer_by_coordinates(layer1_coordinates, soil_material1, "layer1")
        model.add_soil_layer_by_coordinates(layer2_coordinates, soil_material2, "layer2")

        model.synchronise_geometry()

        # check if layers are added correctly
        assert len(model.body_model_parts) == 2
        assert model.body_model_parts[0].name == "layer1"
        assert model.body_model_parts[0].material == soil_material1
        assert model.body_model_parts[1].name == "layer2"
        assert model.body_model_parts[1].material == soil_material2

        # check if geometry is added correctly for each layer
        for i in range(len(model.body_model_parts)):
            generated_geometry = model.body_model_parts[i].geometry
            expected_geometry = expected_geometry_two_layers_3D_extruded[i]

            TestUtils.assert_almost_equal_geometries(expected_geometry, generated_geometry)

    def test_add_all_layers_from_geo_file_2D(self, expected_geometry_two_layers_2D: Tuple[Geometry, Geometry]):
        """
        Tests if all layers are added correctly to the model in a 2D space. A geo file is read and all layers are
        added to the model.

        Args:
            - expected_geometry_two_layers_2D (Tuple[:class:`stem.geometry.Geometry`, :class:`stem.geometry.Geometry`]): \
                expected geometry of the model

        """

        geo_file_name = "tests/test_data/gmsh_utils_two_blocks_2D.geo"

        # create model
        model = Model(ndim=2)
        model.add_all_layers_from_geo_file(geo_file_name, ["group_1"])

        # check if body model parts are added correctly
        assert len(model.body_model_parts) == 1
        assert model.body_model_parts[0].name == "group_1"

        # check if process model part is added correctly
        assert len(model.process_model_parts) == 1
        assert model.process_model_parts[0].name == "group_2"

        # check if geometry is added correctly for each layer
        for i in range(len(model.body_model_parts)):
            generated_geometry = model.body_model_parts[i].geometry
            expected_geometry = expected_geometry_two_layers_2D[i]

            TestUtils.assert_almost_equal_geometries(expected_geometry, generated_geometry)

    def test_add_all_layers_from_geo_file_3D(self, expected_geometry_two_layers_3D_geo_file: Tuple[Geometry, Geometry]):
        """
        Tests if all layers are added correctly to the model in a 3D space. A geo file is read and all layers are
        added to the model.

        Args:
            - expected_geometry_two_layers_3D_geo_file (Tuple[:class:`stem.geometry.Geometry`, \
                :class:`stem.geometry.Geometry`]): expected geometry of the model

        """

        geo_file_name = "tests/test_data/gmsh_utils_column_3D_tetra4.geo"

        # create model
        model = Model(ndim=3)
        model.add_all_layers_from_geo_file(geo_file_name, ["group_1"])

        # check if body model parts are added correctly
        assert len(model.body_model_parts) == 1
        assert model.body_model_parts[0].name == "group_1"

        # check if process model part is added correctly
        assert len(model.process_model_parts) == 1
        assert model.process_model_parts[0].name == "group_2"

        # check if geometry is added correctly
        all_model_parts = []
        all_model_parts.extend(model.body_model_parts)
        all_model_parts.extend(model.process_model_parts)

        # check if geometry is added correctly for each layer
        for i in range(len(all_model_parts)):
            generated_geometry = all_model_parts[i].geometry
            expected_geometry = expected_geometry_two_layers_3D_geo_file[i]

            TestUtils.assert_almost_equal_geometries(expected_geometry, generated_geometry)

    def test_synchronise_geometry_2D(self, expected_geometry_two_layers_2D_after_sync: Tuple[Geometry, Geometry],
                                   create_default_2d_soil_material: SoilMaterial):
        """
        Test if the geometry is synchronised correctly in 2D after adding a new layer to the model. Where the new layer
        overlaps with the existing layer, the existing layer is cut and the overlapping part is removed.

        Args:
            - expected_geometry_two_layers_2D_after_sync (Tuple[:class:`stem.geometry.Geometry`, \
                :class:`stem.geometry.Geometry`, :class:`stem.geometry.Geometry`]): The expected geometry after \
                synchronising the geometry.
            - create_default_2d_soil_material (:class:`stem.soil_material.SoilMaterial`): A default soil material.

        """

        # define layer coordinates
        ndim = 2
        layer1_coordinates = [(0, 0, 0), (1, 0, 0), (1, 1, 0), (0, 1, 0)]
        layer2_coordinates = [(1, 1, 0), (0.5, 1, 0), (0.5, 2, 0), (1, 2, 0)]

        # define soil materials
        soil_material1 = create_default_2d_soil_material
        soil_material1.name = "soil1"

        soil_material2 = create_default_2d_soil_material
        soil_material2.name = "soil2"

        # create model
        model = Model(ndim)

        # add soil layers
        model.add_soil_layer_by_coordinates(layer1_coordinates, soil_material1, "layer1")
        model.add_soil_layer_by_coordinates(layer2_coordinates, soil_material2, "layer2")

        # synchronise geometry and recalculates the ids
        model.synchronise_geometry()

        # collect all generated geometries
        generated_geometries = [model.body_model_parts[0].geometry, model.body_model_parts[1].geometry, model.geometry]

        # check if geometry is added correctly for each layer
        for generated_geometry, expected_geometry in zip(generated_geometries,
                                                         expected_geometry_two_layers_2D_after_sync):

            TestUtils.assert_almost_equal_geometries(expected_geometry, generated_geometry)

    def test_synchronise_geometry_3D(self, create_default_3d_soil_material: SoilMaterial):
        """
        Test if the geometry is synchronised correctly in 3D after adding a new layer to the model. Where the new layer
        overlaps with the existing layer, the existing layer is cut and the overlapping part is removed.

        Args:
            - create_default_3d_soil_material (:class:`stem.soil_material.SoilMaterial`): A default soil material.

        """

        # define layer coordinates
        ndim = 3
        layer1_coordinates = [(0, 0, 0), (1, 0, 0), (1, 1, 0), (0, 1, 0)]
        layer2_coordinates = [(1, 1, 0), (0.5, 1, 0), (0.5, 2, 0), (1, 2, 0)]

        # define soil materials
        soil_material1 = create_default_3d_soil_material
        soil_material1.name = "soil1"

        soil_material2 = create_default_3d_soil_material
        soil_material2.name = "soil2"

        # create model
        model = Model(ndim)
        model.extrusion_length = [0, 0, 1]

        # add soil layers
        model.add_soil_layer_by_coordinates(layer1_coordinates, soil_material1, "layer1")
        model.add_soil_layer_by_coordinates(layer2_coordinates, soil_material2, "layer2")

        # synchronise geometry and recalculates the ids
        model.synchronise_geometry()

        with open("tests/test_data/expected_geometry_after_sync_3D.pickle", "rb") as f:
            expected_geometry_two_layers_3D_after_sync = pickle.load(f)

        # collect all generated geometries
        generated_geometries = [model.body_model_parts[0].geometry, model.body_model_parts[1].geometry, model.geometry]

        # check if geometry is added correctly for each layer
        for generated_geometry, expected_geometry in zip(generated_geometries,
                                                         expected_geometry_two_layers_3D_after_sync):

            TestUtils.assert_almost_equal_geometries(expected_geometry, generated_geometry)

    def test_add_point_loads_to_2_points(self, create_default_point_load_parameters: PointLoad):
        """
        Test if a single soil point load is added correctly to the model. Two points are generated
        and a single load is created and added to the model.

        Args:
            - create_default_point_load_properties (:class:`stem.load.PointLoad`): default point load parameters

        """

        ndim = 3

        point_coordinates = [(-0.5, 0, 0), (0.5, 0, 0)]

        # define soil material
        load_parameters = create_default_point_load_parameters

        # create model
        model = Model(ndim)
        # add soil layer
        model.add_load_by_coordinates(point_coordinates, load_parameters, "point_load_1")

        # check if layer is added correctly
        assert len(model.process_model_parts) == 1
        assert model.process_model_parts[0].name == "point_load_1"
        assert model.process_model_parts[0].parameters == load_parameters

        # check if geometry is added correctly
        generated_geometry = model.process_model_parts[0].geometry
        expected_geometry = Geometry(
            points=[Point.create([-0.5, 0, 0], 1), Point.create([0.5, 0, 0], 2)],
            lines=[],
            surfaces=[],
            volumes=[]
        )

        TestUtils.assert_almost_equal_geometries(expected_geometry, generated_geometry)

    def test_add_line_load_to_3_edges(self, expected_geometry_line_load: Geometry,
                                      create_default_line_load_parameters: PointLoad):
        """
        Test if a line load is added correctly to the model when applied on 3 edges. 4 points are generated
        and a single soil material is created and added to the model.

        Args:
            - expected_geometry_line_load (:class:`stem.geometry.Geometry`): expected geometry of the model
            - create_default_line_load_parameters (:class:`stem.load.LineLoad`): default line load parameters

        """

        ndim = 3

        point_coordinates = [(0, 0, 0), (3, 0, 0), (4, -1, 0), (10, -1, 0)]

        # define soil material
        load_parameters = create_default_line_load_parameters

        # create model
        model = Model(ndim)
        # add line load
        model.add_load_by_coordinates(point_coordinates, load_parameters, "line_load_1")

        # check if layer is added correctly
        assert len(model.process_model_parts) == 1
        assert model.process_model_parts[0].name == "line_load_1"
        assert model.process_model_parts[0].parameters == load_parameters

        # check if geometry is added correctly
        generated_geometry = model.process_model_parts[0].geometry
        expected_geometry = expected_geometry_line_load

        TestUtils.assert_almost_equal_geometries(expected_geometry, generated_geometry)

    def test_add_moving_point_load(self, create_default_moving_load_parameters: MovingLoad):
        """
        Test if a single soil point load is added correctly to the model. Two points are generated
        and a single load is created and added to the model.

        Args:
            - create_default_moving_load_parameters (:class:`stem.load.MovingLoad`): default moving load parameters

        """

        ndim = 3

        point_coordinates = [(0.0, 0, 0), (10, 0, 0)]

        # define soil material
        load_parameters = create_default_moving_load_parameters

        # create model
        model = Model(ndim)
        # add soil layer
        model.add_load_by_coordinates(point_coordinates, load_parameters, "moving_load_1")

        # check if layer is added correctly
        assert len(model.process_model_parts) == 1
        assert model.process_model_parts[0].name == "moving_load_1"
        assert model.process_model_parts[0].parameters == load_parameters

        # check if geometry is added correctly
        generated_geometry = model.process_model_parts[0].geometry
        expected_geometry = Geometry(
            points=[Point.create([0.0, 0, 0], 1), Point.create([10.0, 0, 0], 2)],
            lines=[Line.create([1, 2], 1)],
            surfaces=[],
            volumes=[]
        )

        TestUtils.assert_almost_equal_geometries(expected_geometry, generated_geometry)

    def test_generate_mesh_with_only_a_body_model_part_2d(self, create_default_2d_soil_material: SoilMaterial):
        """
        Test if the mesh is generated correctly in 2D if there is only one body model part.

        Args:
            - create_default_2d_soil_material (:class:`stem.soil_material.SoilMaterial`): A default soil material.

        """
        model = Model(2)

        # add soil material
        soil_material = create_default_2d_soil_material

        # add soil layers
        model.add_soil_layer_by_coordinates([(0, 0, 0), (1, 0, 0), (1, 1, 0), (0, 1, 0)], soil_material, "layer1")
        model.synchronise_geometry()

        # generate mesh
        model.generate_mesh()

        mesh = model.body_model_parts[0].mesh

        assert mesh.ndim == 2

        unique_element_ids = []
        # check if mesh is generated correctly, i.e. if the number of elements is correct and if the element type is
        # correct and if the element ids are unique and if the number of nodes per element is correct
        assert len(mesh.elements) == 162
        for element in mesh.elements:
            assert element.element_type == "TRIANGLE_3N"
            assert element.id not in unique_element_ids
            assert len(element.node_ids) == 3
            unique_element_ids.append(element.id)

        # check if nodes are generated correctly, i.e. if there are nodes in the mesh and if the node ids are unique
        # and if the number of coordinates per node is correct
        unique_node_ids = []
        assert len(mesh.nodes) == 98
        for node in mesh.nodes:
            assert node.id not in unique_node_ids
            assert len(node.coordinates) == 3
            unique_node_ids.append(node.id)

    def test_generate_mesh_with_only_a_body_model_part_3d(self, create_default_3d_soil_material: SoilMaterial):
        """
        Test if the mesh is generated correctly in 3D if there is only one body model part.

        Args:
            - create_default_3d_soil_material (:class:`stem.soil_material.SoilMaterial`): A default soil material.

        """
        model = Model(3)
        model.extrusion_length = [0, 0, 1]

        # add soil material
        soil_material = create_default_3d_soil_material

        # add soil layers
        model.add_soil_layer_by_coordinates([(0, 0, 0), (1, 0, 0), (1, 1, 0), (0, 1, 0)], soil_material, "layer1")
        model.synchronise_geometry()

        # generate mesh
        model.generate_mesh()

        mesh = model.body_model_parts[0].mesh

        assert mesh.ndim == 3

        unique_element_ids = []
        # check if mesh is generated correctly, i.e. if the number of elements is correct and if the element type is
        # correct and if the element ids are unique and if the number of nodes per element is correct
        assert len(mesh.elements) == 1120
        for element in mesh.elements:
            assert element.element_type == "TETRAHEDRON_4N"
            assert element.id not in unique_element_ids
            assert len(element.node_ids) == 4
            unique_element_ids.append(element.id)

        # check if nodes are generated correctly, i.e. if there are nodes in the mesh and if the node ids are unique
        # and if the number of coordinates per node is correct
        unique_node_ids = []
        assert len(mesh.nodes) == 340
        for node in mesh.nodes:
            assert node.id not in unique_node_ids
            assert len(node.coordinates) == 3
            unique_node_ids.append(node.id)

    def test_generate_mesh_with_body_and_process_model_part(self, create_default_2d_soil_material: SoilMaterial):
        """
        Test if the mesh is generated correctly in the body model part and a process model part.

        Args:
            - create_default_2d_soil_material (:class:`stem.soil_material.SoilMaterial`): A default soil material.
        """
        model = Model(2)

        # add soil material
        soil_material = create_default_2d_soil_material

        # add soil layers
        model.add_soil_layer_by_coordinates([(0, 0, 0), (1, 0, 0), (1, 1, 0), (0, 1, 0)], soil_material, "layer1")

        # add process geometry
        gmsh_process_input = {"process_0d": {"coordinates": [[0, 0.5, 0]], "ndim": 0}}
        model.gmsh_io.generate_geometry(gmsh_process_input, "")

        # create process model part
        process_model_part = ModelPart("process_0d")

        # set the geometry of the process model part
        process_model_part.get_geometry_from_geo_data(model.gmsh_io.geo_data, "process_0d")

        # add process model part
        model.process_model_parts.append(process_model_part)

        # synchronise geometry and generate mesh
        model.synchronise_geometry()
        model.generate_mesh()

        # check mesh of body model part
        mesh_body = model.body_model_parts[0].mesh

        assert mesh_body.ndim == 2

        unique_element_ids = []
        # check if mesh is generated correctly, i.e. if the number of elements is correct and if the element type is
        # correct and if the element ids are unique and if the number of nodes per element is correct
        assert len(mesh_body.elements) == 162
        for element in mesh_body.elements:
            assert element.element_type == "TRIANGLE_3N"
            assert element.id not in unique_element_ids
            assert len(element.node_ids) == 3
            unique_element_ids.append(element.id)

        # check if nodes are generated correctly, i.e. if there are nodes in the mesh and if the node ids are unique
        # and if the number of coordinates per node is correct
        unique_body_node_ids = []
        assert len(mesh_body.nodes) == 98
        for node in mesh_body.nodes:
            assert node.id not in unique_body_node_ids
            assert len(node.coordinates) == 3
            unique_body_node_ids.append(node.id)

        # check process model part
        mesh_process = model.process_model_parts[0].mesh

        assert mesh_process.ndim == 0

        # check elements of process model part, i.e. if the number of elements is correct and if the element type is
        # correct and if the element ids are unique and if the number of nodes per element is correct
        assert len(mesh_process.elements) == 1
        for element in mesh_process.elements:
            assert element.element_type == "POINT_1N"
            assert element.id == 1
            assert element.id not in unique_element_ids
            assert len(element.node_ids) == 1
            unique_element_ids.append(element.id)

        # check nodes of process model part, i.e. if there is 1 node in the mesh and if the node ids are present in the
        # body mesh and if the number of coordinates per node is correct
        assert len(mesh_process.nodes) == 1
        for node in mesh_process.nodes:

            # check if node is also available in the body mesh
            assert node.id in unique_body_node_ids
            assert len(node.coordinates) == 3

    def test_validate_expected_success(self):
        """
        Test if the model is validated correctly. A model is created with two process model parts which both have
        a unique name.

        """

        model = Model(2)

        model_part1 = ModelPart("test1")
        model_part2 = ModelPart("test2")

        model.process_model_parts = [model_part1, model_part2]

        model.validate()

    def test_validate_expected_fail_non_unique_names(self):
        """
        Test if the model is validated correctly. A model is created with two process model parts which both have
        the same name. This should raise a ValueError.

        """

        model = Model(2)

        model_part1 = ModelPart("test")
        model_part2 = ModelPart("test")

        model.process_model_parts = [model_part1, model_part2]

        pytest.raises(ValueError, model.validate)

    def test_validate_expected_fail_no_name(self):
        """
        Test if the model is validated correctly. A model is created with a process model part which does not contain
        a name. This should raise a ValueError.

        """

        model = Model(2)

        model_part1 = ModelPart(None)
        model.process_model_parts = [model_part1]

        pytest.raises(ValueError, model.validate)