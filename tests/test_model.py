from typing import Tuple

import pytest

from stem.model import *
from stem.geometry import *


class TestModel:

    @pytest.fixture
    def expected_geo_data_0D(self):
        """
        Expected geometry data for a 0D geometry group. The group is a geometry of a point

        Returns:
            - Dict[str, Any]: dictionary containing the geometry data as generated by the gmsh_io
        """
        expected_points = {1: [0, 0, 0], 2: [0.5, 0, 0]}
        return {"points": expected_points}

    @pytest.fixture
    def expected_geometry_single_layer_2D(self):
        """
        Sets expected geometry data for a 2D geometry group. The group is a geometry of a square.

        Returns:
            - :class:`stem.geometry.Geometry`: geometry of a 2D square
        """

        geometry = Geometry()

        geometry.points = [Point.create([0, 0, 0], 1),
                           Point.create([1, 0, 0], 2),
                           Point.create([1, 1, 0], 3),
                           Point.create([0, 1, 0], 4)]

        geometry.lines = [Line.create([1, 2], 1),
                          Line.create([2, 3], 2),
                          Line.create([3, 4], 3),
                          Line.create([4, 1], 4)]

        geometry.surfaces = [Surface.create([1,2,3,4], 1)]

        geometry.volumes = []

        return geometry

    @pytest.fixture
    def expected_geometry_two_layers_2D(self):
        """
        Sets expected geometries for 2 attached 2D squares.

        Returns:
            - Tuple[:class:`stem.geometry.Geometry`,:class:`stem.geometry.Geometry`]: \
                geometries of 2 attached 2D squares

        """

        geometry_1 = Geometry()

        geometry_1.points = [Point.create([0, 0, 0], 1),
                             Point.create([1, 0, 0], 2),
                             Point.create([1, 1, 0], 3),
                             Point.create([0, 1, 0], 4)]

        geometry_1.lines = [Line.create([1, 2], 1),
                            Line.create([2, 3], 2),
                            Line.create([3, 4], 3),
                            Line.create([4, 1], 4)]

        geometry_1.surfaces = [Surface.create([1, 2, 3, 4], 1)]

        geometry_1.volumes = []

        geometry_2 = Geometry()
        geometry_2.points = [Point.create([1, 1, 0], 3),
                             Point.create([0, 1, 0], 4),
                             Point.create([0, 2, 0], 5),
                             Point.create([1, 2, 0], 6)]

        geometry_2.lines = [Line.create([3, 4], 3),
                            Line.create([4, 5], 5),
                            Line.create([5, 6], 6),
                            Line.create([6, 3], 7)]

        geometry_2.surfaces = [Surface.create([3, 5, 6, 7], 2)]

        geometry_2.volumes = []

        return geometry_1, geometry_2

    @pytest.fixture
    def expected_geometry_two_layers_2D_after_sync(self):
        """
        Sets expected geometry of two model parts and the whole model after synchronising the geometry.

        Returns:
            - Tuple[:class:`stem.geometry.Geometry`,:class:`stem.geometry.Geometry`, \
                :class:`stem.geometry.Geometry`]: geometries of 2 attached 2D squares and the whole model
        """

        # create expected geometry layer 1
        geometry_1 = Geometry()

        geometry_1.points = [Point.create([0, 0, 0], 1),
                             Point.create([1, 0, 0], 2),
                             Point.create([1, 1, 0], 3),
                             Point.create([0.5, 1, 0], 4),
                             Point.create([0, 1, 0], 5)]

        geometry_1.lines = [Line.create([1, 2], 1),
                            Line.create([2, 3], 2),
                            Line.create([3, 4], 3),
                            Line.create([4, 5], 4),
                            Line.create([5, 1], 5)]

        geometry_1.surfaces = [Surface.create([1, 2, 3, 4, 5], 1)]

        geometry_1.volumes = []

        # create expected geometry layer 2
        geometry_2 = Geometry()
        geometry_2.points = [Point.create([1, 1, 0], 3),
                             Point.create([0.5, 1, 0], 4),
                             Point.create([0.5, 2, 0], 6),
                             Point.create([1, 2, 0], 7)]

        geometry_2.lines = [Line.create([3, 4], 3),
                            Line.create([4, 6], 6),
                            Line.create([6, 7], 7),
                            Line.create([7, 3], 8)]

        geometry_2.surfaces = [Surface.create([3, 6, 7, 8], 2)]

        geometry_2.volumes = []

        # create expected full geometry
        full_geometry = Geometry()
        full_geometry.points = [Point.create([0, 0, 0], 1),
                                Point.create([1, 0, 0], 2),
                                Point.create([1, 1, 0], 3),
                                Point.create([0.5, 1, 0], 4),
                                Point.create([0, 1, 0], 5),
                                Point.create([0.5, 2, 0], 6),
                                Point.create([1, 2, 0], 7)]

        full_geometry.lines = [Line.create([1, 2], 1),
                               Line.create([2, 3], 2),
                               Line.create([3, 4], 3),
                               Line.create([4, 5], 4),
                               Line.create([5, 1], 5),
                               Line.create([4, 6], 6),
                               Line.create([6, 7], 7),
                               Line.create([7, 3], 8)]

        full_geometry.surfaces = [Surface.create([1, 2, 3, 4, 5], 1),
                                  Surface.create([3, 6, 7, 8], 2)]

        return geometry_1, geometry_2, full_geometry

    @pytest.fixture
    def create_default_2d_soil_material(self):
        """
        Create a default soil material for a 2D geometry.

        Returns:
            :class:`stem.models.soil.SoilMaterial`: default soil material

        """
        # define soil material
        ndim = 2
        soil_formulation = OnePhaseSoil(ndim, IS_DRAINED=True, DENSITY_SOLID=2650, POROSITY=0.3)
        constitutive_law = LinearElasticSoil(YOUNG_MODULUS=100e6, POISSON_RATIO=0.3)
        soil_material = SoilMaterial(name="soil", soil_formulation=soil_formulation, constitutive_law=constitutive_law,
                                     retention_parameters=SaturatedBelowPhreaticLevelLaw())
        return soil_material

    @pytest.fixture
    def expected_geometry_two_layers_3D(self):
        """
        Expected geometry data for a 3D geometry. The geometry is 2 stacked blocks, where the top and bottom blocks
        are in different groups.

        Returns:
            Tuple[:class:`stem.geometry.Geometry`,:class:`stem.geometry.Geometry`]: expected geometry data
        """

        geometry_1 = Geometry()
        geometry_1.volumes = [Volume.create([-10, 39, 26, 30, 34, 38], 1)]
        geometry_1.surfaces = [Surface.create([5, 6, 7, 8], 10),
                               Surface.create([19, 20, 21, 22], 39),
                               Surface.create([5, 25, -19, -24], 26),
                               Surface.create([6, 29, -20, -25], 30),
                               Surface.create([7, 33, -21, -29], 34),
                               Surface.create([8, 24, -22, -33], 38)]

        geometry_1.lines = [Line.create([1, 2], 5),
                            Line.create([2, 3], 6),
                            Line.create([3, 4], 7),
                            Line.create([4, 1], 8),
                            Line.create([13, 14], 19),
                            Line.create([14, 18], 20),
                            Line.create([18, 22], 21),
                            Line.create([22, 13], 22),
                            Line.create([2, 14], 25),
                            Line.create([1, 13], 24),
                            Line.create([3, 18], 29),
                            Line.create([4, 22], 33)]

        geometry_1.points = [Point.create([0., 0., 0.], 1),
                             Point.create([0.5, 0., 0.], 2),
                             Point.create([0.5, 1., 0.], 3),
                             Point.create([0., 1., 0.], 4),
                             Point.create([0., 0., -0.5], 13),
                             Point.create([0.5, 0., -0.5], 14),
                             Point.create([0.5, 1., -0.5], 18),
                             Point.create([0., 1., -0.5], 22)]

        geometry_2 = Geometry()
        geometry_2.volumes = [Volume.create([-17, 61, -48, -34, -56, -60], 2)]

        geometry_2.surfaces = [Surface.create([-13, -7, -15, -14],17),
                               Surface.create([41, -21, 43, 44], 61),
                               Surface.create([-13, 33, -41, -46], 48),
                               Surface.create([7, 33, -21, -29], 34),
                               Surface.create([-15, 55, -43, -29], 56),
                               Surface.create([-14, 46, -44, -55], 60)]

        geometry_2.lines = [Line.create([4, 11], 13),
                            Line.create([3, 4], 7),
                            Line.create([12, 3], 15),
                            Line.create([11, 12], 14),
                            Line.create([23, 22], 41),
                            Line.create([18, 22], 21),
                            Line.create([18, 32], 43),
                            Line.create([32, 23], 44),
                            Line.create([4, 22], 33),
                            Line.create([11, 23], 46),
                            Line.create([3, 18], 29),
                            Line.create([12, 32], 55)]

        geometry_2.points = [Point.create([0., 1., 0.], 4),
                             Point.create([0., 2., 0.], 11),
                             Point.create([0.5, 1., 0.], 3),
                             Point.create([0.5, 2., 0.], 12),
                             Point.create([0., 2., -0.5], 23),
                             Point.create([0., 1., -0.5], 22),
                             Point.create([0.5, 1., -0.5], 18),
                             Point.create([0.5, 2., -0.5], 32)]

        return geometry_1, geometry_2

    def test_add_single_soil_layer_2D(self, expected_geometry_single_layer_2D: Geometry,
                                      create_default_2d_soil_material: SoilMaterial):
        """
        Test if a single soil layer is added correctly to the model in a 2D space. A single soil layer is generated
        and a single soil material is created and added to the model.

        Args:
            - expected_geometry_single_layer_2D (:class:`stem.geometry.Geometry`): expected geometry of the model
            - create_default_2d_soil_material (:class:`stem.soil_material.SoilMaterial`): default soil material

        """

        ndim = 2

        layer_coordinates = [(0, 0, 0), (1, 0, 0), (1, 1, 0), (0, 1, 0)]

        # define soil material
        soil_material = create_default_2d_soil_material

        # create model
        model = Model(ndim)

        # add soil layer
        model.add_soil_layer_by_coordinates(layer_coordinates, soil_material, "soil1")

        # check if layer is added correctly
        assert len(model.body_model_parts) == 1
        assert model.body_model_parts[0].name == "soil1"
        assert model.body_model_parts[0].material == soil_material

        # check if geometry is added correctly
        generated_geometry = model.body_model_parts[0].geometry
        expected_geometry = expected_geometry_single_layer_2D

        # check if points are added correctly
        for generated_point, expected_point in zip(generated_geometry.points, expected_geometry.points):
            assert generated_point.id == expected_point.id
            assert pytest.approx(generated_point.coordinates) == expected_point.coordinates

        # check if lines are added correctly
        for generated_line, expected_line in zip(generated_geometry.lines, expected_geometry.lines):
            assert generated_line.id == expected_line.id
            assert generated_line.point_ids == expected_line.point_ids

        # check if surfaces are added correctly
        for generated_surface, expected_surface in zip(generated_geometry.surfaces, expected_geometry.surfaces):
            assert generated_surface.id == expected_surface.id
            assert generated_surface.line_ids == expected_surface.line_ids

    def test_add_multiple_soil_layers_2D(self, expected_geometry_two_layers_2D: Tuple[Geometry, Geometry],
                                         create_default_2d_soil_material: SoilMaterial):
        """
        Test if multiple soil layers are added correctly to the model in a 2D space. Multiple soil layers are generated
        and multiple soil materials are created and added to the model.

        Args:
            - expected_geometry_two_layers_2D (Tuple[:class:`stem.geometry.Geometry`, :class:`stem.geometry.Geometry`]): \
                expected geometry of the model
            - create_default_2d_soil_material (:class:`stem.soil_material.SoilMaterial`): default soil material

        """

        ndim = 2

        layer1_coordinates = [(0, 0, 0), (1, 0, 0), (1, 1, 0), (0, 1, 0)]
        layer2_coordinates = [(1, 1, 0), (0, 1, 0), (0, 2, 0), (1, 2, 0)]

        # define soil materials
        soil_material1 = create_default_2d_soil_material
        soil_material1.name = "soil1"

        soil_material2 = create_default_2d_soil_material
        soil_material2.name = "soil2"

        # create model
        model = Model(ndim)

        # add soil layers
        model.add_soil_layer_by_coordinates(layer1_coordinates, soil_material1, "layer1")
        model.add_soil_layer_by_coordinates(layer2_coordinates, soil_material2, "layer2")

        # check if layers are added correctly
        assert len(model.body_model_parts) == 2
        assert model.body_model_parts[0].name == "layer1"
        assert model.body_model_parts[0].material == soil_material1
        assert model.body_model_parts[1].name == "layer2"
        assert model.body_model_parts[1].material == soil_material2

        # check if geometry is added correctly for each layer
        for i in range(len(model.body_model_parts)):
            generated_geometry = model.body_model_parts[i].geometry
            expected_geometry = expected_geometry_two_layers_2D[i]

            # check if points are added correctly
            for generated_point, expected_point in zip(generated_geometry.points, expected_geometry.points):
                assert generated_point.id == expected_point.id
                assert pytest.approx(generated_point.coordinates) == expected_point.coordinates

            # check if lines are added correctly
            for generated_line, expected_line in zip(generated_geometry.lines, expected_geometry.lines):
                assert generated_line.id == expected_line.id
                assert generated_line.point_ids == expected_line.point_ids

            # check if surfaces are added correctly
            for generated_surface, expected_surface in zip(generated_geometry.surfaces, expected_geometry.surfaces):
                assert generated_surface.id == expected_surface.id
                assert generated_surface.line_ids == expected_surface.line_ids

    def test_add_all_layers_from_geo_file_2D(self, expected_geometry_two_layers_2D: Tuple[Geometry, Geometry]):
        """
        Tests if all layers are added correctly to the model in a 2D space. A geo file is read and all layers are
        added to the model.

        Args:
            - expected_geometry_two_layers_2D (Tuple[:class:`stem.geometry.Geometry`, :class:`stem.geometry.Geometry`]): \
                expected geometry of the model

        """

        geo_file_name = "tests/test_data/gmsh_utils_two_blocks_2D.geo"

        # create model
        model = Model(ndim=2)
        model.add_all_layers_from_geo_file(geo_file_name, ["group_1"])

        # check if body model parts are added correctly
        assert len(model.body_model_parts) == 1
        assert model.body_model_parts[0].name == "group_1"

        # check if process model part is added correctly
        assert len(model.process_model_parts) == 1
        assert model.process_model_parts[0].name == "group_2"

        # check if geometry is added correctly for each layer
        for i in range(len(model.body_model_parts)):
            generated_geometry = model.body_model_parts[i].geometry
            expected_geometry = expected_geometry_two_layers_2D[i]

            # check if points are added correctly
            for generated_point, expected_point in zip(generated_geometry.points, expected_geometry.points):
                assert generated_point.id == expected_point.id
                assert pytest.approx(generated_point.coordinates) == expected_point.coordinates

            # check if lines are added correctly
            for generated_line, expected_line in zip(generated_geometry.lines, expected_geometry.lines):
                assert generated_line.id == expected_line.id
                assert generated_line.point_ids == expected_line.point_ids

            # check if surfaces are added correctly
            for generated_surface, expected_surface in zip(generated_geometry.surfaces, expected_geometry.surfaces):
                assert generated_surface.id == expected_surface.id
                assert generated_surface.line_ids == expected_surface.line_ids

    def test_add_all_layers_from_geo_file_3D(self, expected_geometry_two_layers_3D: Tuple[Geometry, Geometry]):
        """
        Tests if all layers are added correctly to the model in a 3D space. A geo file is read and all layers are
        added to the model.

        Args:
            - expected_geometry_two_layers_3D (Tuple[:class:`stem.geometry.Geometry`, :class:`stem.geometry.Geometry`]): \
                expected geometry of the model

        """

        geo_file_name = "tests/test_data/gmsh_utils_column_3D_tetra4.geo"

        # create model
        model = Model(ndim=3)
        model.add_all_layers_from_geo_file(geo_file_name, ["group_1"])

        # check if body model parts are added correctly
        assert len(model.body_model_parts) == 1
        assert model.body_model_parts[0].name == "group_1"

        # check if process model part is added correctly
        assert len(model.process_model_parts) == 1
        assert model.process_model_parts[0].name == "group_2"

        # check if geometry is added correctly
        all_model_parts = []
        all_model_parts.extend(model.body_model_parts)
        all_model_parts.extend(model.process_model_parts)

        # check if geometry is added correctly for each layer
        for i in range(len(all_model_parts)):
            generated_geometry = all_model_parts[i].geometry
            expected_geometry = expected_geometry_two_layers_3D[i]

            # check if points are added correctly
            for generated_point, expected_point in zip(generated_geometry.points, expected_geometry.points):
                assert generated_point.id == expected_point.id
                assert pytest.approx(generated_point.coordinates) == expected_point.coordinates

            # check if lines are added correctly
            for generated_line, expected_line in zip(generated_geometry.lines, expected_geometry.lines):
                assert generated_line.id == expected_line.id
                assert generated_line.point_ids == expected_line.point_ids

            # check if surfaces are added correctly
            for generated_surface, expected_surface in zip(generated_geometry.surfaces, expected_geometry.surfaces):
                assert generated_surface.id == expected_surface.id
                assert generated_surface.line_ids == expected_surface.line_ids

    def test_synchronise_geometry(self, expected_geometry_two_layers_2D_after_sync: Tuple[Geometry, Geometry],
                                   create_default_2d_soil_material: SoilMaterial):
        """
        Test if the geometry is synchronised correctly after adding a new layer to the model. Where the new layer
        overlaps with the existing layer, the existing layer is cut and the overlapping part is removed.

        Args:
            - expected_geometry_two_layers_2D_after_sync (Tuple[:class:`stem.geometry.Geometry`, \
                :class:`stem.geometry.Geometry`, :class:`stem.geometry.Geometry`]): The expected geometry after \
                synchronising the geometry.
            - create_default_2d_soil_material (:class:`stem.soil_material.SoilMaterial`): A default soil material.

        """

        # define layer coordinates
        ndim = 2
        layer1_coordinates = [(0, 0, 0), (1, 0, 0), (1, 1, 0), (0, 1, 0)]
        layer2_coordinates = [(1, 1, 0), (0.5, 1, 0), (0.5, 2, 0), (1, 2, 0)]

        # define soil materials
        soil_material1 = create_default_2d_soil_material
        soil_material1.name = "soil1"

        soil_material2 = create_default_2d_soil_material
        soil_material2.name = "soil2"

        # create model
        model = Model(ndim)

        # add soil layers
        model.add_soil_layer_by_coordinates(layer1_coordinates, soil_material1, "layer1")
        model.add_soil_layer_by_coordinates(layer2_coordinates, soil_material2, "layer2")

        # synchronise geometry and recalculates the ids
        model.synchronise_geometry()

        # collect all generated geometries
        generated_geometries = [model.body_model_parts[0].geometry, model.body_model_parts[1].geometry, model.geometry]

        # check if geometry is added correctly for each layer
        for generated_geometry, expected_geometry in zip(generated_geometries,
                                                         expected_geometry_two_layers_2D_after_sync):

            # check if points are added correctly
            for generated_point, expected_point in zip(generated_geometry.points, expected_geometry.points):
                assert generated_point.id == expected_point.id
                assert pytest.approx(generated_point.coordinates) == expected_point.coordinates

            # check if lines are added correctly
            for generated_line, expected_line in zip(generated_geometry.lines, expected_geometry.lines):
                assert generated_line.id == expected_line.id
                assert generated_line.point_ids == expected_line.point_ids

            # check if surfaces are added correctly
            for generated_surface, expected_surface in zip(generated_geometry.surfaces, expected_geometry.surfaces):
                assert generated_surface.id == expected_surface.id
                assert generated_surface.line_ids == expected_surface.line_ids
