import gmsh
import sys
import numpy as np
# from points_input import input_points, mesh_size, dims, depth, save_file, gmsh_interface


# define the points of the surface as a list of tuples
input_points = [(0, 0, 0), (1, 0, 0), (1, 3, 0), (0, 3, 0), (-1, 1.5, 0)]
# define the mesh size
mesh_size = 2
# define geometry dimension; input "3" for 3D to extrude the 2D surface, input "2" for 2D
dims = 3
# input depth of geometry if 3D
depth = 2
# set a name label for the surface
name_label = "Soil Layer"
# if True, saves mesh data to separate mdpa files
save_file = True
# if True, opens gmsh interface
gmsh_interface = True
# set a name for mesh output file
mesh_output_name = "geometry"


def create_point(coordinates, mesh_size):
    """
    creates points in gmsh
    :param coordinates: gets points coordinates in order from user
    :param mesh_size: gets mesh size from user
    :return: -
    """
    x = coordinates[0]
    y = coordinates[1]
    z = coordinates[2]
    lc = mesh_size
    gmsh.model.geo.addPoint(x, y, z, lc)


def create_line(point_ids):
    """
    creates lines in gmsh
    :param point_ids: gets point tags in order
    :return: -
    """
    point1 = point_ids[0]
    point2 = point_ids[1]
    gmsh.model.geo.addLine(point1, point2)


def create_surface(line_ids, name_label):
    """
    creates curve and then surface in gmsh by using line tags
    :param line_ids: gets line tags in order
    :param name_label: surface name label from user input
    :return: returns the surface tag and surface name label
    """
    gmsh.model.geo.addCurveLoop(line_ids, 1)
    surfaces = gmsh.model.geo.addPlaneSurface([1], 1)
    gmsh.model.setPhysicalName(2, surfaces, name_label)
    return surfaces


def create_volume(surface_id, depth):
    """
    creates volume by extruding 2D surface
    :param surface_id: surface tag
    :param depth: depth of 3D geometry
    :return: -
    """
    gmsh.model.geo.extrude([(2, surface_id)], 0, 0, depth)


def make_elements(point_coordinates, point_pairs, mesh_size, name_label):
    """
    takes point_pairs and puts their tags as the beginning and end of line in gmsh to create line
    then creates surface
    :param point_coordinates: point coordinates
    :param point_pairs: has been generated by storing point tags of two consecutive points in an array
    :param mesh_size: mesh size
    :param name_label: surface name label from user input
    :return: creates points, lines and surface elements
    """
    for point in point_coordinates:
        coordinate = [point[0], point[1], point[2]]
        create_point(coordinate, mesh_size)

    line_lists = []

    for i in range(len(point_pairs)):
        line = [point_pairs[i][0], point_pairs[i][1]]
        line_lists.append(i + 1)
        create_line(line)

    surfaces = create_surface(line_lists, name_label)
    return surfaces


def make_geometry_3D(point_coordinates, point_pairs, mesh_size, depth, name_label):
    """
    creates 3D geometries by extruding the 2D surface
    :param point_coordinates: geometry points coordinates
    :param point_pairs: points paired for lines
    :param mesh_size: mesh size
    :param depth: depth of 3D geometry
    :param name_label: surface name label from user input
    :return: -
    """
    surfaces = make_elements(point_coordinates, point_pairs, mesh_size, name_label)
    create_volume(surfaces, depth)


def make_geometry_2D(point_coordinates, point_pairs, mesh_size, name_label):
    """
    creates 2D geometries
    :param point_coordinates: geometry points coordinates
    :param point_pairs: points paired for lines
    :param mesh_size: mesh size
    :param name_label: surface name label from user input
    :return: -
    """
    make_elements(point_coordinates, point_pairs, mesh_size, name_label)


def extract_mesh_data(dims):
    """
    gets gmsh output data
    :param dims: geometry dimension (2=2D or 3=3D)
    :return: geometry and mesh data: node tags, node coordinates, element types, element tags 0D, 1D, 2D, 3D
    """
    node_tags, node_coords, node_params = gmsh.model.mesh.getNodes()  # nodes, elements
    elem_types, elem_tags, elem_node_tags = gmsh.model.mesh.getElements()
    print(elem_types)
    num_elem = sum(len(i) for i in elem_tags)
    print(" - Mesh has " + str(len(node_tags)) + " nodes and " + str(num_elem) +
          " elements")

    num_nodes = len(node_tags)
    coord = np.reshape(node_coords, (num_nodes, 3))

    if elem_types[0] == 1:
        node_shape = 2
        num_1d_elements = len(elem_tags[0])
        node_tag_1D = np.reshape(elem_node_tags[0], (num_1d_elements, node_shape))

    if elem_types[1] == 2:
        node_shape = 3  # node_shape amount of nodes in element
        num_2d_elements = len(elem_tags[1])
        node_tag_2D = np.reshape(elem_node_tags[1], (num_2d_elements, node_shape))

    if dims == 3:
        if elem_types[2] == 4:
            node_shape = 4
            num_3d_elements = len(elem_tags[2])
            node_tag_3D = np.reshape(elem_node_tags[2], (num_3d_elements, node_shape))
        return coord, node_tags, elem_types, elem_tags, node_tag_1D, node_tag_2D, node_tag_3D

    if dims == 2:
        return coord, node_tags, elem_types, elem_tags, node_tag_1D, node_tag_2D


def generate_gmsh_mesh(point_coordinates, point_pairs, depth, mesh_size, dims, save_file, name_label):
    """
    generates mesh for geometries in gmsh
    :param point_coordinates: geometry points coordinates
    :param point_pairs: points paired for lines
    :param depth: depth of 3D geometry
    :param mesh_size: mesh size
    :param dims: geometry dimension (2=2D or 3=3D)
    :param save_file: if True saves mesh data to mdpa files
    :param name_label: surface name label from user input
    :return: saves mesh data and opens gmsh interface
    """
    gmsh.initialize()
    gmsh.model.add(mesh_output_name)

    volumes = []
    if dims == 3:
        make_geometry_3D(point_coordinates, point_pairs, mesh_size, depth, name_label)
        gmsh.model.geo.synchronize()
        gmsh.model.mesh.generate(dims)
        # extract mesh data
        node_coords, node_tags, elem_types, elem_tags, node_tag_1D, node_tag_2D, node_tag_3D = extract_mesh_data(dims)
        nodes, lines, surfaces = get_data_for_kratos(node_coords, node_tags, elem_tags, node_tag_1D, node_tag_2D)
        volumes = np.concatenate((elem_tags[2][:, None], np.array(node_tag_3D)), axis=1)

    if dims == 2:
        make_geometry_2D(point_coordinates, point_pairs, mesh_size, name_label)
        gmsh.model.geo.synchronize()
        gmsh.model.mesh.generate(dims)
        # extract mesh data
        node_coords, node_tags, elem_types, elem_tags, node_tag_1D, node_tag_2D = extract_mesh_data(dims)
        nodes, lines, surfaces = get_data_for_kratos(node_coords, node_tags, elem_tags, node_tag_1D, node_tag_2D)

    if save_file is True:
        save_mesh_data(nodes, lines, surfaces, volumes)

    # writes mesh file output in .msh format
    file_extension = ".msh"
    mesh_output_file = mesh_output_name + file_extension
    gmsh.write(mesh_output_file)

    # opens GMsh interface
    if gmsh_interface is True:
        gmsh.fltk.run()
    gmsh.finalize()


def get_data_for_kratos(node_coords, node_tags, elem_tags, node_tag_1D, node_tag_2D):
    """
    gets mesh data for Kratos
    :param node_coords: node coordinates
    :param node_tags: node tags
    :param elem_tags: all element tags in an array separated by element type
    :param node_tag_1D: node tags of start and end of line
    :param node_tag_2D: node tags of surface
    :return: node tag followed by node coordinates and element tag followed by node tags in an array
    """
    nodes = np.concatenate((node_tags[:, None], np.array(node_coords)), axis=1)
    lines = np.concatenate((elem_tags[0][:, None], np.array(node_tag_1D)), axis=1)
    surfaces = np.concatenate((elem_tags[1][:, None], np.array(node_tag_2D)), axis=1)

    return nodes, lines, surfaces


def save_mesh_data(nodes, lines, surfaces, volumes):
    """
    saves mesh data to mdpa file
    :param nodes: node tag followed by node coordinates in an array
    :param lines: line tag followed by node tags of start and end of line in an array
    :param surfaces: surface tag followed by node tags of surface in an array
    :param volumes: volume tag followed by node tags of volume in an array
    :return: -
    """
    np.savetxt('0.nodes.mdpa', nodes, fmt=['%.f', '%.10f', '%.10f', '%.10f'], delimiter=' ')
    np.savetxt('1.lines.mdpa', lines, delimiter=' ')
    np.savetxt('2.surfaces.mdpa', surfaces, delimiter=' ')
    np.savetxt('3.volumes.mdpa', volumes, delimiter=' ')


def create_point_pairs(points):
    """
    crates point pairs by storing point tags of two consecutive points in an array
    :param points: user input points of the surface as a list of tuples
    :return: creates point pairs
    """
    point_pairs = []
    for i in range(len(points) - 1):
        # puts two consecutive points tags as the beginning and end of line in an array
        point_pair = [i + 1, i + 2]
        point_pairs.append(point_pair)
    # make a pair that connects last point to first point
    point_pairs.append([len(points), 1])
    return point_pairs


if __name__ == '__main__':
    point_pairs = create_point_pairs(input_points)
    generate_gmsh_mesh(input_points, point_pairs, depth, mesh_size, dims, save_file, name_label)
