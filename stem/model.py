from typing import List, Sequence, Dict, Any, Optional, Union
from enum import Enum
from dataclasses import dataclass

from gmsh_utils import gmsh_IO

from stem.model_part import ModelPart, BodyModelPart
from stem.soil_material import *
from stem.structural_material import *
from stem.geometry import Geometry
from stem.mesh import Mesh, MeshSettings


class Model:
    """
    A class to represent the main model.

    Attributes:
        - ndim (int): Number of dimensions of the model
        - project_parameters (dict): A dictionary containing the project parameters.
        - solver (:class:`stem.solver.Solver`): The solver used to solve the problem.
        - geometry (Optional[:class:`stem.geometry.Geometry`]) The geometry of the whole model.
        - body_model_parts (List[:class:`stem.model_part.BodyModelPart`]): A list containing the body model parts.
        - process_model_parts (List[:class:`stem.model_part.ModelPart`]): A list containing the process model parts.
        - extrusion_length (Optional[Sequence[float]]): The extrusion length in x, y and z direction

    """
    def __init__(self, ndim: int):
        self.ndim: int = ndim
        self.project_parameters = None
        self.solver = None
        self.geometry: Optional[Geometry] = None
        self.mesh_settings: MeshSettings = MeshSettings()
        self.gmsh_io = gmsh_IO.GmshIO()
        self.body_model_parts: List[BodyModelPart] = []
        self.process_model_parts: List[ModelPart] = []

        self.extrusion_length: Optional[Sequence[float]] = None

    def __del__(self):
        """
        Destructor of the Model class. Finalizes the gmsh_io instance.

        """
        self.gmsh_io.finalize_gmsh()

    def __get_geometry_from_geo_data(self, geo_data: Dict[str, Any]):
        """
        Get the geometry from the geo_data as generated by gmsh_io.

        Args:
            - geo_data (Dict[str, Any]): dictionary containing the geometry data as generated by the gmsh_io

        """

        self.geometry = Geometry.create_geometry_from_geo_data(geo_data)

    def add_all_layers_from_geo_file(self, geo_file_name: str, body_names: Sequence[str]):
        """
        Add all physical groups from a geo file to the model. The physical groups with the names in body_names are
        added as body model parts, the other physical groups are added as process model parts.

        Args:
            - geo_file_name (str): name of the geo file
            - body_names (Sequence[str]): names of the physical groups which should be added as body model parts

        """

        # read the geo file and generate the geo_data dictionary
        self.gmsh_io.read_gmsh_geo(geo_file_name)

        # Reset the gmsh instance with the geo data, as read from the geo file
        self.gmsh_io.generate_geo_from_geo_data()

        geo_data = self.gmsh_io.geo_data

        # Create geometry and model part for each physical group in the gmsh geo_data
        model_part: Union[ModelPart, BodyModelPart]
        for group_name in geo_data["physical_groups"].keys():

            # create model part, if the group name is in the body names, create a body model part, otherwise a process
            # model part
            if group_name in body_names:
                model_part = BodyModelPart(group_name)
            else:
                model_part = ModelPart(group_name)

            # set the name and geometry of the model part
            model_part.get_geometry_from_geo_data(geo_data, group_name)

            # add model part to either body model parts or process model part
            if isinstance(model_part, BodyModelPart):
                self.body_model_parts.append(model_part)
            else:
                self.process_model_parts.append(model_part)

    def add_soil_layer_by_coordinates(self, coordinates: Sequence[Sequence[float]],
                       material_parameters: Union[SoilMaterial, StructuralMaterial], name: str,
                       ):
        """
        Adds a soil layer to the model by giving a sequence of 2D coordinates. In 3D the 2D geometry is extruded in
        the direction of the extrusion_length

        Args:
            - coordinates (Sequence[Sequence[float]]): The plane coordinates of the soil layer.
            - material_parameters (Union[:class:`stem.soil_material.SoilMaterial`, \
                :class:`stem.structural_material.StructuralMaterial`]): The material parameters of the soil layer.
            - name (str): The name of the soil layer.

        """

        gmsh_input = {name: {"coordinates": coordinates, "ndim": self.ndim}}
        # check if extrusion length is specified in 3D
        if self.ndim == 3:
            if self.extrusion_length is None:
                raise ValueError("Extrusion length must be specified for 3D models")

            gmsh_input[name]["extrusion_length"] = self.extrusion_length

        # todo check if this function in gmsh io can be improved
        self.gmsh_io.generate_geometry(gmsh_input, "")

        # create body model part
        body_model_part = BodyModelPart(name)
        body_model_part.material = material_parameters

        # set the geometry of the body model part
        body_model_part.get_geometry_from_geo_data(self.gmsh_io.geo_data, name)

        self.body_model_parts.append(body_model_part)

    def synchronise_geometry(self):
        """
        Synchronise the geometry of all model parts and synchronise the geometry of the whole model. This function
        recalculates all ids and connectivities of all geometrical entities.

        """

        # synchronize gmsh and extract geo data
        self.gmsh_io.synchronize_gmsh()
        self.gmsh_io.extract_geo_data()

        # collect all model parts
        all_model_parts: List[Union[BodyModelPart, ModelPart]] = []
        all_model_parts.extend(self.body_model_parts)
        all_model_parts.extend(self.process_model_parts)

        # Get the geometry from the geo_data for each model part
        for model_part in all_model_parts:
            model_part.get_geometry_from_geo_data(self.gmsh_io.geo_data, model_part.name)

        # get the complete geometry
        self.__get_geometry_from_geo_data(self.gmsh_io.geo_data)

    def generate_mesh(self):
        """
        Generate the mesh for the whole model.

        """

        # generate mesh
        self.gmsh_io.generate_mesh(self.ndim, element_size=self.mesh_settings.element_size,
                                   order=self.mesh_settings.element_order)

        # collect all model parts
        all_model_parts: List[Union[BodyModelPart, ModelPart]] = []
        all_model_parts.extend(self.body_model_parts)
        all_model_parts.extend(self.process_model_parts)

        # add the mesh to each model part
        for model_part in all_model_parts:
            model_part.mesh = Mesh.create_mesh_from_gmsh_group(self.gmsh_io.mesh_data, model_part.name)

    def __validate_model_part_names(self):
        """
        Checks if all model parts have a unique name.

        Raises:
            - ValueError: If not all model parts have a name.
            - ValueError: If not all model part names are unique .
        """

        # collect all model parts
        all_model_parts: List[Union[BodyModelPart, ModelPart]] = []
        all_model_parts.extend(self.body_model_parts)
        all_model_parts.extend(self.process_model_parts)

        unique_names = []
        for model_part in all_model_parts:
            # Check if all model parts have a name
            if model_part.name is None:
                raise ValueError("All model parts must have a name")
            else:
                if model_part.name in unique_names:
                    raise ValueError("All model parts must have a unique name")
                unique_names.append(model_part.name)

    def validate(self):
        """
        Validate the model. \
            - Checks if all model parts have a unique name.

        """

        self.__validate_model_part_names()


    def show_geometry_from_geometry_data(self,show_surface_ids: bool = True, show_line_ids: bool = True,
                                         show_point_ids: bool = True):
        import numpy as np
        from mpl_toolkits.mplot3d import Axes3D
        # Axes3D import has side effects, it enables using projection='3d' in add_subplot
        import matplotlib.pyplot as plt

        from mpl_toolkits.mplot3d.art3d import Poly3DCollection

        # Initialize figure in 3D
        fig = plt.figure()
        ax = fig.add_subplot(111, projection='3d')

        # get geo data
        geo_data = self.gmsh_io.geo_data

        # loop over all volumes
        for volume_k, volume_connectivities in geo_data["volumes"].items():

            # loop over all surfaces within the volume
            for surface_k in volume_connectivities:

                surface_point_ids = []
                surface_connectivities = geo_data["surfaces"][abs(surface_k)]

                # calculate centroids of lines to show line ids
                line_centroids = []
                for line_k in surface_connectivities:
                    line_connectivities = geo_data["lines"][abs(line_k)]
                    # reverse line connectivity if line is defined in opposite direction
                    if line_k < 0:
                        line_connectivities = line_connectivities[::-1]

                    line_centroids.append(np.mean([geo_data["points"][line_connectivities[0]],
                                                   geo_data["points"][line_connectivities[1]]], axis=0))

                    surface_point_ids.extend(line_connectivities)

                # get unique points within surface
                unique_points = []
                for point_id in surface_point_ids:

                    if point_id not in unique_points:
                        unique_points.append(point_id)


                # get coordinates of surface points
                surface_point_coordinates = np.array([geo_data["points"][point_id] for point_id in unique_points])

                # set vertices in format as required by Poly3DCollection
                vertices = [list(zip(surface_point_coordinates[:, 0],
                                     surface_point_coordinates[:, 1],
                                     surface_point_coordinates[:, 2]))]

                # create Poly3DCollection
                poly = Poly3DCollection(vertices, facecolors='blue', linewidths=1, edgecolors='black', alpha=0.35)

                # show surface ids
                if show_surface_ids:
                    surface_centroid = np.mean(surface_point_coordinates, axis=0)
                    ax.text(surface_centroid[0], surface_centroid[1], surface_centroid[2], f"s_{abs(surface_k)}",
                            color='black', fontsize=14, fontweight='bold')

                # show line ids
                if show_line_ids:
                    for line_centroid, line_k in zip(line_centroids, surface_connectivities):
                        ax.text(line_centroid[0], line_centroid[1], line_centroid[2], f"l_{abs(line_k)}",
                                color='black', fontsize=14, fontweight='bold')

                # show point ids
                if show_point_ids:
                    for point_id, point_coordinates in geo_data["points"].items():
                        ax.text(point_coordinates[0], point_coordinates[1], point_coordinates[2], f"p_{point_id}",
                                color='black', fontsize=14, fontweight='bold')

                # add Poly3DCollection to figure
                ax.add_collection3d(poly)

        fig.show()

